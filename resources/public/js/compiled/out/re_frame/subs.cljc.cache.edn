{:rename-macros {}, :renames {}, :externs {Error {}}, :use-macros {reagent-id re-frame.interop, console re-frame.loggers, dispose! re-frame.interop, add-on-dispose! re-frame.interop, make-reaction re-frame.interop, deref? re-frame.interop, ratom? re-frame.interop, debug-enabled? re-frame.interop}, :excludes #{}, :name re-frame.subs, :imports nil, :requires {re-frame.db re-frame.db, re-frame.interop re-frame.interop, re-frame.loggers re-frame.loggers, re-frame.utils re-frame.utils, re-frame.registrar re-frame.registrar, trace re-frame.trace, re-frame.trace re-frame.trace}, :cljs.spec/speced-vars [], :uses {reagent-id re-frame.interop, console re-frame.loggers, app-db re-frame.db, dispose! re-frame.interop, add-on-dispose! re-frame.interop, make-reaction re-frame.interop, get-handler re-frame.registrar, first-in-vector re-frame.utils, deref? re-frame.interop, ratom? re-frame.interop, debug-enabled? re-frame.interop, clear-handlers re-frame.registrar, register-handler re-frame.registrar}, :defs {cache-and-return {:protocol-inline nil, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/subs.cljc", :line 42, :column 7, :end-line 42, :end-column 23, :arglists (quote ([query-v dynv r])), :doc "cache the reaction r"}, :name re-frame.subs/cache-and-return, :variadic false, :file "resources/public/js/compiled/out/re_frame/subs.cljc", :end-column 23, :method-params ([query-v dynv r]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 42, :end-line 42, :max-fixed-arity 3, :fn-var true, :arglists (quote ([query-v dynv r])), :doc "cache the reaction r"}, deref-input-signals {:protocol-inline nil, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/subs.cljc", :line 165, :column 8, :end-line 165, :end-column 27, :private true, :arglists (quote ([signals query-id]))}, :private true, :name re-frame.subs/deref-input-signals, :variadic false, :file "resources/public/js/compiled/out/re_frame/subs.cljc", :end-column 27, :method-params ([signals query-id]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 165, :end-line 165, :max-fixed-arity 2, :fn-var true, :arglists (quote ([signals query-id]))}, subscribe {:protocol-inline nil, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/subs.cljc", :line 67, :column 7, :end-line 67, :end-column 16, :arglists (quote ([query] [query dynv])), :doc "Given a `query`, returns a Reagent `reaction` which, over\n  time, reactively delivers a stream of values. So in FRP-ish terms,\n  it returns a Signal.\n\n  To obtain the returned Signal/Stream's current value, it must be `deref`ed.\n\n  `query` is a vector of at least one element. The first element is the\n  `query-id`, typically a namespaced keyword. The rest of the vector's\n  elements are optional, additional values which parameterise the query\n  performed.\n\n  `dynv` is an optional 3rd argument, `which is a vector of further input\n  signals (atoms, reactions, etc), NOT values. This argument exists for\n  historical reasons and is borderline deprecated these days.\n\n  Example Usage:\n  --------------\n\n    (subscribe [:items])\n    (subscribe [:items \"blue\" :small])\n    (subscribe [:items {:colour \"blue\"  :size :small}])\n\n  Note: for any given call to `subscribe` there must have been a previous call\n  to `reg-sub`, registering the query handler (function) for the `query-id` given.\n\n  Hint\n  ----\n\n  When used in a view function BE SURE to `deref` the returned value.\n  In fact, to avoid any mistakes, some prefer to define:\n\n     (def <sub  (comp deref re-frame.core/subscribe))\n\n  And then, within their views, they call  `(<sub [:items :small])` rather\n  than using `subscribe` directly.\n\n  De-duplication\n  --------------\n\n  XXX\n  ", :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([query] [query dynv]), :arglists ([query] [query dynv]), :arglists-meta (nil nil)}}, :name re-frame.subs/subscribe, :variadic false, :file "resources/public/js/compiled/out/re_frame/subs.cljc", :end-column 16, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([query] [query dynv]), :arglists ([query] [query dynv]), :arglists-meta (nil nil)}, :method-params ([query] [query dynv]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 67, :end-line 67, :max-fixed-arity 2, :fn-var true, :arglists ([query] [query dynv]), :doc "Given a `query`, returns a Reagent `reaction` which, over\n  time, reactively delivers a stream of values. So in FRP-ish terms,\n  it returns a Signal.\n\n  To obtain the returned Signal/Stream's current value, it must be `deref`ed.\n\n  `query` is a vector of at least one element. The first element is the\n  `query-id`, typically a namespaced keyword. The rest of the vector's\n  elements are optional, additional values which parameterise the query\n  performed.\n\n  `dynv` is an optional 3rd argument, `which is a vector of further input\n  signals (atoms, reactions, etc), NOT values. This argument exists for\n  historical reasons and is borderline deprecated these days.\n\n  Example Usage:\n  --------------\n\n    (subscribe [:items])\n    (subscribe [:items \"blue\" :small])\n    (subscribe [:items {:colour \"blue\"  :size :small}])\n\n  Note: for any given call to `subscribe` there must have been a previous call\n  to `reg-sub`, registering the query handler (function) for the `query-id` given.\n\n  Hint\n  ----\n\n  When used in a view function BE SURE to `deref` the returned value.\n  In fact, to avoid any mistakes, some prefer to define:\n\n     (def <sub  (comp deref re-frame.core/subscribe))\n\n  And then, within their views, they call  `(<sub [:items :small])` rather\n  than using `subscribe` directly.\n\n  De-duplication\n  --------------\n\n  XXX\n  "}, reg-sub {:protocol-inline nil, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/subs.cljc", :line 176, :column 7, :end-line 176, :end-column 14, :arglists (quote ([query-id & args])), :doc "For a given `query-id`, register a `computation` function and input `signals`.\n\n  At an abstract level, a call to this function allows you to register 'the mechanism'\n  to later fulfil a call to `(subscribe [query-id ...])`.\n\n  To say that another way, reg-sub allows you to create a template for a node\n  in the signal graph. But note: reg-sub does not cause a node to be created.\n  It simply allows you to register the template from which such a\n  node could be created, if it were needed, sometime later, when the call\n  to `subscribe` is made.\n\n  reg-sub needs three things:\n    - a `query-id`\n    - the required inputs for this node\n    - a computation function for this node\n\n  The `query-id` is always the 1st argument to reg-sub and it is typically\n  a namespaced keyword.\n\n  A computation function is always the last argument and it has this general form:\n    `(input-signals, query-vector) -> a-value`\n\n  What goes in between the 1st and last args can vary, but whatever is there will\n  define the input signals part of the template, and, as a result, it will control\n  what values the computation functions gets as a first argument.\n\n  There's 3 ways this function can be called - 3 ways to supply input signals:\n\n  1. No input signals given:\n\n     (reg-sub\n       :query-id\n       a-computation-fn)   ;; (fn [db v]  ... a-value)\n\n     The node's input signal defaults to `app-db`, and the value within `app-db` is\n     is given as the 1st argument to the computation function.\n\n  2. A signal function is supplied:\n\n     (reg-sub\n       :query-id\n       signal-fn     ;; <-- here\n       computation-fn)\n\n     When a node is created from the template, the `signal-fn` will be called and it\n     is expected to return the input signal(s) as either a singleton, if there is only\n     one, or a sequence if there are many, or a map with the signals as the values.\n\n     The values from the nominated signals will be supplied as the 1st argument to the\n     computation function - either a singleton, sequence or map of them, paralleling\n     the structure returned by the signal function.\n\n     Here, is an example signal-fn, which returns a vector of input signals.\n\n       (fn [query-vec dynamic-vec]\n         [(subscribe [:a-sub])\n          (subscribe [:b-sub])])\n\n     For that signal function, the computation function must be written\n     to expect a vector of values for its first argument.\n       (fn [[a b] _] ....)\n\n     If the signal function was simpler and returned a singleton, like this:\n        (fn [query-vec dynamic-vec]\n          (subscribe [:a-sub]))\n\n     then the computation function must be written to expect a single value\n     as the 1st argument:\n\n        (fn [a _] ...)\n\n  3. Syntax Sugar\n\n     (reg-sub\n       :a-b-sub\n       :<- [:a-sub]\n       :<- [:b-sub]\n       (fn [[a b] [_]] {:a a :b b}))\n\n  This 3rd variation is syntactic sugar for the 2nd. Pairs are supplied instead\n  of an `input signals` functions. Each pair starts with a `:<-` and a subscription\n  vector follows.\n\n  For further understanding, read `/docs`, and look at the detailed comments in\n  /examples/todomvc/src/subs.cljs\n  ", :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(query-id args)], :arglists ([query-id & args]), :arglists-meta (nil)}}, :name re-frame.subs/reg-sub, :variadic true, :file "resources/public/js/compiled/out/re_frame/subs.cljc", :end-column 14, :top-fn {:variadic true, :max-fixed-arity 1, :method-params [(query-id args)], :arglists ([query-id & args]), :arglists-meta (nil)}, :method-params [(query-id args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 176, :end-line 176, :max-fixed-arity 1, :fn-var true, :arglists ([query-id & args]), :doc "For a given `query-id`, register a `computation` function and input `signals`.\n\n  At an abstract level, a call to this function allows you to register 'the mechanism'\n  to later fulfil a call to `(subscribe [query-id ...])`.\n\n  To say that another way, reg-sub allows you to create a template for a node\n  in the signal graph. But note: reg-sub does not cause a node to be created.\n  It simply allows you to register the template from which such a\n  node could be created, if it were needed, sometime later, when the call\n  to `subscribe` is made.\n\n  reg-sub needs three things:\n    - a `query-id`\n    - the required inputs for this node\n    - a computation function for this node\n\n  The `query-id` is always the 1st argument to reg-sub and it is typically\n  a namespaced keyword.\n\n  A computation function is always the last argument and it has this general form:\n    `(input-signals, query-vector) -> a-value`\n\n  What goes in between the 1st and last args can vary, but whatever is there will\n  define the input signals part of the template, and, as a result, it will control\n  what values the computation functions gets as a first argument.\n\n  There's 3 ways this function can be called - 3 ways to supply input signals:\n\n  1. No input signals given:\n\n     (reg-sub\n       :query-id\n       a-computation-fn)   ;; (fn [db v]  ... a-value)\n\n     The node's input signal defaults to `app-db`, and the value within `app-db` is\n     is given as the 1st argument to the computation function.\n\n  2. A signal function is supplied:\n\n     (reg-sub\n       :query-id\n       signal-fn     ;; <-- here\n       computation-fn)\n\n     When a node is created from the template, the `signal-fn` will be called and it\n     is expected to return the input signal(s) as either a singleton, if there is only\n     one, or a sequence if there are many, or a map with the signals as the values.\n\n     The values from the nominated signals will be supplied as the 1st argument to the\n     computation function - either a singleton, sequence or map of them, paralleling\n     the structure returned by the signal function.\n\n     Here, is an example signal-fn, which returns a vector of input signals.\n\n       (fn [query-vec dynamic-vec]\n         [(subscribe [:a-sub])\n          (subscribe [:b-sub])])\n\n     For that signal function, the computation function must be written\n     to expect a vector of values for its first argument.\n       (fn [[a b] _] ....)\n\n     If the signal function was simpler and returned a singleton, like this:\n        (fn [query-vec dynamic-vec]\n          (subscribe [:a-sub]))\n\n     then the computation function must be written to expect a single value\n     as the 1st argument:\n\n        (fn [a _] ...)\n\n  3. Syntax Sugar\n\n     (reg-sub\n       :a-b-sub\n       :<- [:a-sub]\n       :<- [:b-sub]\n       (fn [[a b] [_]] {:a a :b b}))\n\n  This 3rd variation is syntactic sugar for the 2nd. Pairs are supplied instead\n  of an `input signals` functions. Each pair starts with a `:<-` and a subscription\n  vector follows.\n\n  For further understanding, read `/docs`, and look at the detailed comments in\n  /examples/todomvc/src/subs.cljs\n  "}, query->reaction {:name re-frame.subs/query->reaction, :file "resources/public/js/compiled/out/re_frame/subs.cljc", :line 18, :column 1, :end-line 18, :end-column 21, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/subs.cljc", :line 18, :column 6, :end-line 18, :end-column 21}, :tag any}, clear-all-handlers! {:protocol-inline nil, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/subs.cljc", :line 36, :column 7, :end-line 36, :end-column 26, :arglists (quote ([])), :doc "Unregisters all existing subscription handlers"}, :name re-frame.subs/clear-all-handlers!, :variadic false, :file "resources/public/js/compiled/out/re_frame/subs.cljc", :end-column 26, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 36, :end-line 36, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Unregisters all existing subscription handlers"}, cache-lookup {:protocol-inline nil, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/subs.cljc", :line 58, :column 7, :end-line 58, :end-column 19, :arglists (quote ([query-v] [query-v dyn-v])), :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([query-v] [query-v dyn-v]), :arglists ([query-v] [query-v dyn-v]), :arglists-meta (nil nil)}}, :name re-frame.subs/cache-lookup, :variadic false, :file "resources/public/js/compiled/out/re_frame/subs.cljc", :end-column 19, :top-fn {:variadic false, :max-fixed-arity 2, :method-params ([query-v] [query-v dyn-v]), :arglists ([query-v] [query-v dyn-v]), :arglists-meta (nil nil)}, :method-params ([query-v] [query-v dyn-v]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 58, :end-line 58, :max-fixed-arity 2, :fn-var true, :arglists ([query-v] [query-v dyn-v])}, map-vals {:protocol-inline nil, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/subs.cljc", :line 156, :column 8, :end-line 156, :end-column 16, :private true, :arglists (quote ([f m])), :doc "Returns a new version of 'm' in which 'f' has been applied to each value.\n  (map-vals inc {:a 4, :b 2}) => {:a 5, :b 3}"}, :private true, :name re-frame.subs/map-vals, :variadic false, :file "resources/public/js/compiled/out/re_frame/subs.cljc", :end-column 16, :method-params ([f m]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 156, :end-line 156, :max-fixed-arity 2, :fn-var true, :arglists (quote ([f m])), :doc "Returns a new version of 'm' in which 'f' has been applied to each value.\n  (map-vals inc {:a 4, :b 2}) => {:a 5, :b 3}"}, kind {:name re-frame.subs/kind, :file "resources/public/js/compiled/out/re_frame/subs.cljc", :line 10, :column 1, :end-line 10, :end-column 10, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/subs.cljc", :line 10, :column 6, :end-line 10, :end-column 10}, :tag cljs.core/Keyword}, clear-subscription-cache! {:protocol-inline nil, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/subs.cljc", :line 20, :column 7, :end-line 20, :end-column 32, :arglists (quote ([])), :doc "Causes all subscriptions to be removed from the cache.\n  Does this by:\n     1. running on-dispose on all cached subscriptions\n     2. These on-dispose will then do the removal of themselves.\n\n  This is a development time tool. Useful when reloading Figwheel code\n  after a React exception, because React components won't have been\n  cleaned up properly. And this, in turn, means the subscriptions within those\n  components won't have been cleaned up correctly. So this forces the issue."}, :name re-frame.subs/clear-subscription-cache!, :variadic false, :file "resources/public/js/compiled/out/re_frame/subs.cljc", :end-column 32, :method-params ([]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 20, :end-line 20, :max-fixed-arity 0, :fn-var true, :arglists (quote ([])), :doc "Causes all subscriptions to be removed from the cache.\n  Does this by:\n     1. running on-dispose on all cached subscriptions\n     2. These on-dispose will then do the removal of themselves.\n\n  This is a development time tool. Useful when reloading Figwheel code\n  after a React exception, because React components won't have been\n  cleaned up properly. And this, in turn, means the subscriptions within those\n  components won't have been cleaned up correctly. So this forces the issue."}}, :cljs.spec/registry-ref [], :require-macros {trace re-frame.trace, re-frame.trace re-frame.trace}, :cljs.analyzer/constants {:seen #{:dyn-v :tags :sub/run :else :<- :sub :sub/create :warn :value :operation :start :duration :query-v :cached? :sub/dispose :error :input-signals :end :reaction :op-type}, :order [:sub :warn :operation :op-type :tags :sub/dispose :query-v :reaction :start :error :else :duration :end :sub/create :cached? :dyn-v :input-signals :<- :sub/run :value]}, :doc nil}