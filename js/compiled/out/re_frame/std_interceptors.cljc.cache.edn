{:rename-macros {}, :renames {}, :use-macros {console re-frame.loggers}, :excludes #{}, :name re-frame.std-interceptors, :imports nil, :requires {cofx re-frame.cofx, re-frame.interceptor re-frame.interceptor, data clojure.data, re-frame.registrar re-frame.registrar, registrar re-frame.registrar, re-frame.utils re-frame.utils, re-frame.loggers re-frame.loggers, utils re-frame.utils, re-frame.cofx re-frame.cofx, clojure.data clojure.data, re-frame.db re-frame.db}, :cljs.spec/speced-vars [], :uses {console re-frame.loggers, assoc-coeffect re-frame.interceptor, app-db re-frame.db, get-effect re-frame.interceptor, ->interceptor re-frame.interceptor, get-coeffect re-frame.interceptor, assoc-effect re-frame.interceptor}, :defs {debug {:name re-frame.std-interceptors/debug, :file "resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :line 13, :column 1, :end-line 13, :end-column 11, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :line 13, :column 6, :end-line 13, :end-column 11}, :doc "An interceptor which logs/instruments an event handler's actions to\n  `js/console.debug`. See examples/todomvc/src/events.cljs for use.\n\n  Output includes:\n  1. the event vector\n  2. a `clojure.data/diff` of db, before vs after, which shows\n     the changes caused by the event handler.  You will absolutely have\n     to understand https://clojuredocs.org/clojure.data/diff to\n     understand the output.\n\n  You'd typically include this interceptor after (to the right of) any\n  path interceptor.\n\n  Warning:  calling clojure.data/diff on large, complex data structures\n  can be slow. So, you won't want this interceptor present in production\n  code. So condition it out like this :\n\n    (re-frame.core/reg-event-db\n       :evt-id\n       [(when ^boolean goog.DEBUG re-frame.core/debug)]  ;; <-- conditional\n       (fn [db v]\n         ...))\n\n  To make this code fragment work, you'll also have to set goog.DEBUG to\n  false in your production builds - look in `project.clj` of /examples/todomvc.\n  ", :tag any}, trim-v {:name re-frame.std-interceptors/trim-v, :file "resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :line 64, :column 1, :end-line 64, :end-column 12, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :line 64, :column 6, :end-line 64, :end-column 12}, :doc "An interceptor which removes the first element of the event vector,\n  allowing you to write more aesthetically pleasing event handlers. No\n  leading underscore on the event-v!\n  Your event handlers will look like this:\n\n      (defn my-handler\n        [db [x y z]]    ;; <-- instead of [_ x y z]\n        ....)", :tag any}, db-handler->interceptor {:protocol-inline nil, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :line 92, :column 7, :end-line 92, :end-column 30, :arglists (quote ([handler-fn])), :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-db`.\n\n  These handlers take two arguments;  `db` and `event`, and they return `db`.\n\n  (fn [db event]\n     ....)\n\n  So, the interceptor wraps the given handler:\n     1. extracts two `:coeffects` keys: db and event\n     2. calls handler-fn\n     3. stores the db result back into context's `:effects`"}, :name re-frame.std-interceptors/db-handler->interceptor, :variadic false, :file "resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :end-column 30, :method-params ([handler-fn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 92, :end-line 92, :max-fixed-arity 1, :fn-var true, :arglists (quote ([handler-fn])), :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-db`.\n\n  These handlers take two arguments;  `db` and `event`, and they return `db`.\n\n  (fn [db event]\n     ....)\n\n  So, the interceptor wraps the given handler:\n     1. extracts two `:coeffects` keys: db and event\n     2. calls handler-fn\n     3. stores the db result back into context's `:effects`"}, fx-handler->interceptor {:protocol-inline nil, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :line 114, :column 7, :end-line 114, :end-column 30, :arglists (quote ([handler-fn])), :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-fx`.\n\n  These handlers take two arguments;  `coeffects` and `event`, and they return `effects`.\n\n  (fn [coeffects event]\n     {:db ...\n      :dispatch ...})\n\n   Wrap handler in an interceptor so it can be added to (the RHS) of a chain:\n     1. extracts `:coeffects`\n     2. call handler-fn giving coeffects\n     3. stores the result back into the `:effects`"}, :name re-frame.std-interceptors/fx-handler->interceptor, :variadic false, :file "resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :end-column 30, :method-params ([handler-fn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 114, :end-line 114, :max-fixed-arity 1, :fn-var true, :arglists (quote ([handler-fn])), :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-fx`.\n\n  These handlers take two arguments;  `coeffects` and `event`, and they return `effects`.\n\n  (fn [coeffects event]\n     {:db ...\n      :dispatch ...})\n\n   Wrap handler in an interceptor so it can be added to (the RHS) of a chain:\n     1. extracts `:coeffects`\n     2. call handler-fn giving coeffects\n     3. stores the result back into the `:effects`"}, ctx-handler->interceptor {:protocol-inline nil, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :line 137, :column 7, :end-line 137, :end-column 31, :arglists (quote ([handler-fn])), :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-ctx`.\n  These advanced handlers take one argument: `context` and they return a modified `context`.\n  Example:\n     (fn [context]\n        (enqueue context [more interceptors]))"}, :name re-frame.std-interceptors/ctx-handler->interceptor, :variadic false, :file "resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :end-column 31, :method-params ([handler-fn]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 137, :end-line 137, :max-fixed-arity 1, :fn-var true, :arglists (quote ([handler-fn])), :doc "Returns an interceptor which wraps the kind of event handler given to `reg-event-ctx`.\n  These advanced handlers take one argument: `context` and they return a modified `context`.\n  Example:\n     (fn [context]\n        (enqueue context [more interceptors]))"}, path {:protocol-inline nil, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :line 152, :column 7, :end-line 152, :end-column 11, :arglists (quote ([& args])), :doc "returns an interceptor whose `:before` substitutes the coeffects `:db` with\n  a sub-path of `:db`. Within `:after` it grafts the handler's return value\n  back into db, at the right path.\n\n  So, its overall action is to make the event handler behave like the function\n  you might give to clojure's `update-in`.\n\n  Examples:\n    (path :some :path)\n    (path [:some :path])\n    (path [:some :path] :to :here)\n    (path [:some :path] [:to] :here)\n\n  Example Use:\n\n    (reg-event-db\n      :event-id\n      (path [:a :b])  ;; used here, in interceptor chain\n      (fn [b v]       ;; 1st arg is now not db. Is the value from path [:a :b] within db\n        ... new-b))   ;; returns a new value for that path (not the entire db)\n\n  Notes:\n    1. `path` may appear more than once in an interceptor chain. Progressive narrowing.\n    2. if `:effects` contains no `:db` effect, can't graft a value back in.\n  ", :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}}, :name re-frame.std-interceptors/path, :variadic true, :file "resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :end-column 11, :top-fn {:variadic true, :max-fixed-arity 0, :method-params [(args)], :arglists ([& args]), :arglists-meta (nil)}, :method-params [(args)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 152, :end-line 152, :max-fixed-arity 0, :fn-var true, :arglists ([& args]), :doc "returns an interceptor whose `:before` substitutes the coeffects `:db` with\n  a sub-path of `:db`. Within `:after` it grafts the handler's return value\n  back into db, at the right path.\n\n  So, its overall action is to make the event handler behave like the function\n  you might give to clojure's `update-in`.\n\n  Examples:\n    (path :some :path)\n    (path [:some :path])\n    (path [:some :path] :to :here)\n    (path [:some :path] [:to] :here)\n\n  Example Use:\n\n    (reg-event-db\n      :event-id\n      (path [:a :b])  ;; used here, in interceptor chain\n      (fn [b v]       ;; 1st arg is now not db. Is the value from path [:a :b] within db\n        ... new-b))   ;; returns a new value for that path (not the entire db)\n\n  Notes:\n    1. `path` may appear more than once in an interceptor chain. Progressive narrowing.\n    2. if `:effects` contains no `:db` effect, can't graft a value back in.\n  "}, enrich {:protocol-inline nil, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :line 206, :column 7, :end-line 206, :end-column 13, :arglists (quote ([f])), :doc "Interceptor factory which runs the given function `f` in the `after handler`\n  position.  `f` is called with two arguments: `db` and `v`, and is expected to\n  return a modified `db`.\n\n  Unlike the `after` interceptor which is only about side effects, `enrich`\n  expects `f` to process and alter the given `db` coeffect in some useful way,\n  contributing to the derived data, flowing vibe.\n\n  Example Use:\n  ------------\n\n  Imagine that todomvc needed to do duplicate detection - if any two todos had\n  the same text, then highlight their background, and report them via a warning\n  at the bottom of the panel.\n\n  Almost any user action (edit text, add new todo, remove a todo) requires a\n  complete reassessment of duplication errors and warnings. Eg: that edit\n  just made might have introduced a new duplicate, or removed one. Same with\n  any todo removal. So we need to re-calculate warnings after any CRUD events\n  associated with the todos list.\n\n  Unless we are careful, we might end up coding subtly different checks\n  for each kind of CRUD operation.  The duplicates check made after\n  'delete todo' event might be subtly different to that done after an\n  editing operation. Nice and efficient, but fiddly. A bug generator\n  approach.\n\n  So, instead, we create an `f` which recalculates ALL warnings from scratch\n  every time there is ANY change. It will inspect all the todos, and\n  reset ALL FLAGS every time (overwriting what was there previously)\n  and fully recalculate the list of duplicates (displayed at the bottom?).\n\n  https://twitter.com/nathanmarz/status/879722740776939520\n\n  By applying `f` in an `:enrich` interceptor, after every CRUD event,\n  we keep the handlers simple and yet we ensure this important step\n  (of getting warnings right) is not missed on any change.\n\n  We can test `f` easily - it is a pure function - independently of\n  any CRUD operation.\n\n  This brings huge simplicity at the expense of some re-computation\n  each time. This may be a very satisfactory trade-off in many cases."}, :name re-frame.std-interceptors/enrich, :variadic false, :file "resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :end-column 13, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 206, :end-line 206, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "Interceptor factory which runs the given function `f` in the `after handler`\n  position.  `f` is called with two arguments: `db` and `v`, and is expected to\n  return a modified `db`.\n\n  Unlike the `after` interceptor which is only about side effects, `enrich`\n  expects `f` to process and alter the given `db` coeffect in some useful way,\n  contributing to the derived data, flowing vibe.\n\n  Example Use:\n  ------------\n\n  Imagine that todomvc needed to do duplicate detection - if any two todos had\n  the same text, then highlight their background, and report them via a warning\n  at the bottom of the panel.\n\n  Almost any user action (edit text, add new todo, remove a todo) requires a\n  complete reassessment of duplication errors and warnings. Eg: that edit\n  just made might have introduced a new duplicate, or removed one. Same with\n  any todo removal. So we need to re-calculate warnings after any CRUD events\n  associated with the todos list.\n\n  Unless we are careful, we might end up coding subtly different checks\n  for each kind of CRUD operation.  The duplicates check made after\n  'delete todo' event might be subtly different to that done after an\n  editing operation. Nice and efficient, but fiddly. A bug generator\n  approach.\n\n  So, instead, we create an `f` which recalculates ALL warnings from scratch\n  every time there is ANY change. It will inspect all the todos, and\n  reset ALL FLAGS every time (overwriting what was there previously)\n  and fully recalculate the list of duplicates (displayed at the bottom?).\n\n  https://twitter.com/nathanmarz/status/879722740776939520\n\n  By applying `f` in an `:enrich` interceptor, after every CRUD event,\n  we keep the handlers simple and yet we ensure this important step\n  (of getting warnings right) is not missed on any change.\n\n  We can test `f` easily - it is a pure function - independently of\n  any CRUD operation.\n\n  This brings huge simplicity at the expense of some re-computation\n  each time. This may be a very satisfactory trade-off in many cases."}, after {:protocol-inline nil, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :line 264, :column 7, :end-line 264, :end-column 12, :arglists (quote ([f])), :doc "returns an interceptor which runs a given function `f` in the `:after`\n  position, presumably for side effects.\n\n  `f` is called with two arguments: the `:effects` value for `:db`\n  (or the `coeffect` value of db if no db effect is returned) and the event.\n  Its return value is ignored, so `f` can only side-effect.\n\n  Examples use can be seen in the /examples/todomvc:\n     - `f` runs schema validation (reporting any errors found).\n     - `f` writes to localstorage."}, :name re-frame.std-interceptors/after, :variadic false, :file "resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :end-column 12, :method-params ([f]), :protocol-impl nil, :arglists-meta (nil nil), :column 1, :line 264, :end-line 264, :max-fixed-arity 1, :fn-var true, :arglists (quote ([f])), :doc "returns an interceptor which runs a given function `f` in the `:after`\n  position, presumably for side effects.\n\n  `f` is called with two arguments: the `:effects` value for `:db`\n  (or the `coeffect` value of db if no db effect is returned) and the event.\n  Its return value is ignored, so `f` can only side-effect.\n\n  Examples use can be seen in the /examples/todomvc:\n     - `f` runs schema validation (reporting any errors found).\n     - `f` writes to localstorage."}, on-changes {:protocol-inline nil, :meta {:file "/home/tushaar/Projects/maze-evolution/resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :line 288, :column 8, :end-line 288, :end-column 18, :arglists (quote ([f out-path & in-paths])), :doc "Interceptor factory which acts a bit like `reaction`  (but it flows into\n  `db`, rather than out). It observes N paths within `db` and if any of them\n  test not identical? to their previous value  (as a result of a event handler\n  being run) then it runs `f` to compute a new value, which is then assoc-ed\n  into the given `out-path` within `db`.\n\n  Usage:\n\n  (defn my-f\n    [a-val b-val]\n    ... some computation on a and b in here)\n\n  (on-changes my-f [:c]  [:a] [:b])\n\n  Put this Interceptor on the right handlers (ones which might change :a or :b).\n  It will:\n     - call `f` each time the value at path [:a] or [:b] changes\n     - call `f` with the values extracted from [:a] [:b]\n     - assoc the return value from `f` into the path  [:c]\n  ", :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(f out-path in-paths)], :arglists ([f out-path & in-paths]), :arglists-meta (nil)}}, :name re-frame.std-interceptors/on-changes, :variadic true, :file "resources/public/js/compiled/out/re_frame/std_interceptors.cljc", :end-column 18, :top-fn {:variadic true, :max-fixed-arity 2, :method-params [(f out-path in-paths)], :arglists ([f out-path & in-paths]), :arglists-meta (nil)}, :method-params [(f out-path in-paths)], :protocol-impl nil, :arglists-meta (nil), :column 1, :line 288, :end-line 288, :max-fixed-arity 2, :fn-var true, :arglists ([f out-path & in-paths]), :doc "Interceptor factory which acts a bit like `reaction`  (but it flows into\n  `db`, rather than out). It observes N paths within `db` and if any of them\n  test not identical? to their previous value  (as a result of a event handler\n  being run) then it runs `f` to compute a new value, which is then assoc-ed\n  into the given `out-path` within `db`.\n\n  Usage:\n\n  (defn my-f\n    [a-val b-val]\n    ... some computation on a and b in here)\n\n  (on-changes my-f [:c]  [:a] [:b])\n\n  Put this Interceptor on the right handlers (ones which might change :a or :b).\n  It will:\n     - call `f` each time the value at path [:a] or [:b] changes\n     - call `f` with the values extracted from [:a] [:b]\n     - assoc the return value from `f` into the path  [:c]\n  "}}, :cljs.spec/registry-ref [], :require-macros nil, :cljs.analyzer/constants {:seen #{:path :group :db :fx-handler :re-frame.std-interceptors/not-found :debug :trim-v :db-handler :event :after :id :effects :error :coeffects :re-frame-path/db-store :on-changes :groupEnd :ctx-handler :enrich :before :log :re-frame.std-interceptors/untrimmed-event}, :order [:id :debug :before :log :event :after :db :re-frame.std-interceptors/not-found :group :groupEnd :trim-v :coeffects :re-frame.std-interceptors/untrimmed-event :db-handler :fx-handler :effects :ctx-handler :re-frame-path/db-store :error :path :enrich :on-changes]}, :doc "contains re-frame supplied, standard interceptors"}